{"version":3,"file":"lapidary.es5.js","sources":["../src/constants.ts","../src/operations.ts","../src/utilities.ts","../src/helpers.ts","../src/lapidary.ts"],"sourcesContent":["const BETWEEN = 'between'\nconst CASE_INSENSITIVE_EQUAL = '='\nconst CASE_INSENSITIVE_NOT_EQUAL = '!='\nconst CASE_SENSITIVE_EQUAL = '=='\nconst CASE_SENSITIVE_NOT_EQUAL = '!=='\nconst CONTAINS = 'contains'\nconst EQUAL = '='\nconst GREATER_THAN = '>'\nconst GREATER_THAN_OR_EQUAL = '>='\nconst IMPLICIT = ''\nconst INCLUSIVE_BETWEEN = 'inbetween'\nconst IS = 'is'\nconst LESS_THAN = '<'\nconst LESS_THAN_OR_EQUAL = '<='\nconst NOT_EQUAL = '!='\nconst NUMERIC = 'numeric'\nconst STRING = 'string'\n\nconst COMPARISONS = [\n  NOT_EQUAL,\n  LESS_THAN,\n  GREATER_THAN,\n  LESS_THAN_OR_EQUAL,\n  GREATER_THAN_OR_EQUAL,\n  EQUAL,\n  CONTAINS\n]\n\nconst AND = 'AND'\nconst OR = 'OR'\nconst NOT = 'NOT'\n\nconst JOINS = [AND, OR]\n\n/* SUGGESTION REGEX */\n\nconst FACET_SUGGESTION_REGEX = /\\w+/gi\n\n/* END SUGGESTION REGEX */\n\nexport {\n  AND,\n  BETWEEN,\n  CASE_INSENSITIVE_EQUAL,\n  CASE_INSENSITIVE_NOT_EQUAL,\n  CASE_SENSITIVE_EQUAL,\n  CASE_SENSITIVE_NOT_EQUAL,\n  COMPARISONS,\n  CONTAINS,\n  EQUAL,\n  FACET_SUGGESTION_REGEX,\n  GREATER_THAN,\n  GREATER_THAN_OR_EQUAL,\n  IMPLICIT,\n  INCLUSIVE_BETWEEN,\n  IS,\n  JOINS,\n  LESS_THAN,\n  LESS_THAN_OR_EQUAL,\n  NOT,\n  NOT_EQUAL,\n  NUMERIC,\n  OR,\n  STRING\n}\n","import { FilterEvaluator, FilterGenerator, Item, Facets, OperationMapping } from './types'\n\nimport Lapidary from './lapidary'\nimport {\n  BETWEEN,\n  CASE_INSENSITIVE_EQUAL,\n  CASE_INSENSITIVE_NOT_EQUAL,\n  CASE_SENSITIVE_EQUAL,\n  CASE_SENSITIVE_NOT_EQUAL,\n  CONTAINS,\n  EQUAL,\n  GREATER_THAN,\n  GREATER_THAN_OR_EQUAL,\n  INCLUSIVE_BETWEEN,\n  LESS_THAN,\n  LESS_THAN_OR_EQUAL,\n  NOT_EQUAL\n} from './constants'\n\n// String quotes when doing string operations\nconst cleanString = (s: string | undefined, facetKey: string | number) => {\n  if (typeof s === 'undefined' || s === '') {\n    throw new Error(`Expected a value for \"${facetKey}\"`)\n  }\n  return s.replace(/['\"]+/g, '')\n}\n// Interpret string value as number\nconst cleanNumber = (n: string, facetKey: string | number) => {\n  const num = Number(n)\n  if (isNaN(num)) {\n    throw new Error(`Expected a numeric value for \"${facetKey}\". Received \"${n}\"`)\n  }\n  return num\n}\n\nconst StringEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] === cleanString(expression, facetKey)\n  }\n}\n\nconst StringCaseInsensetiveEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey].toLowerCase() === cleanString(expression, facetKey).toLowerCase()\n  }\n}\n\nconst StringContainsEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey].indexOf(cleanString(expression, facetKey)) >= 0\n  }\n}\n\nconst StringNegativeEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] !== cleanString(expression, facetKey)\n  }\n}\n\nconst StringNegativeCaseInsensitiveEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey].toLowerCase() !== cleanString(expression, facetKey).toLowerCase()\n  }\n}\n\nconst NumericEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] === cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericNegativeEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] !== cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericLTEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] < cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericLTEEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] <= cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericGTEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] > cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericGTEEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] >= cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericBetweenEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    const [lower, upper] = expression.split(',')\n    return (\n      item[objectKey] > cleanNumber(lower, facetKey) &&\n      item[objectKey] < cleanNumber(upper, facetKey)\n    )\n  }\n}\n\nconst NumericInclusiveBetweenEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    const [lower, upper] = expression.split(',')\n    return (\n      item[objectKey] >= cleanNumber(lower, facetKey) &&\n      item[objectKey] <= cleanNumber(upper, facetKey)\n    )\n  }\n}\n\nconst DefaultEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => l.defaultFacet(item, facetKey)\n}\n\nconst StringOperations: OperationMapping = {\n  [CASE_SENSITIVE_EQUAL]: StringEqualityEvaluationGenerator,\n  [CASE_SENSITIVE_NOT_EQUAL]: StringNegativeEqualityEvaluationGenerator,\n  [CASE_INSENSITIVE_EQUAL]: StringCaseInsensetiveEqualityEvaluationGenerator,\n  [CASE_INSENSITIVE_NOT_EQUAL]: StringNegativeCaseInsensitiveEqualityEvaluationGenerator,\n  [CONTAINS]: StringContainsEvaluationGenerator\n}\n\nconst NumericOperations: OperationMapping = {\n  [EQUAL]: NumericEqualityEvaluationGenerator,\n  [NOT_EQUAL]: NumericNegativeEqualityEvaluationGenerator,\n  [GREATER_THAN]: NumericGTEvaluationGenerator,\n  [LESS_THAN]: NumericLTEvaluationGenerator,\n  [GREATER_THAN_OR_EQUAL]: NumericGTEEvaluationGenerator,\n  [LESS_THAN_OR_EQUAL]: NumericLTEEvaluationGenerator,\n  [BETWEEN]: NumericBetweenEvaluationGenerator,\n  [INCLUSIVE_BETWEEN]: NumericInclusiveBetweenEvaluationGenerator\n}\n\nexport { StringOperations, NumericOperations, DefaultEvaluationGenerator }\n","// https://gist.github.com/scottrippey/1349099\nexport const splitBalanced = (\n  input: string,\n  /* istanbul ignore next */\n  split: string = ' ',\n  open: string = '',\n  close: string = '',\n  toggle: string = '',\n  escape: string = ''\n): string[] => {\n  // Build the pattern from params with defaults:\n  const pattern = '([\\\\s\\\\S]*?)(e)?(?:(o)|(c)|(t)|(sp)|$)'\n    .replace('sp', split)\n    .replace('o', open || '[\\\\(\\\\{\\\\[]')\n    .replace('c', close || '[\\\\)\\\\}\\\\]]')\n    .replace('t', toggle || '[\\'\"]')\n    .replace('e', escape || '[\\\\\\\\]')\n  const r = new RegExp(pattern, 'gi')\n  const stack: string[] = []\n  let buffer: string[] = []\n  const results: string[] = []\n  // Clone the input string\n  const clonedInput = '' + input\n  clonedInput.replace(r, ($0, $1, $e, $o, $c, $t, $s, i) => {\n    if ($e) {\n      // Escape\n      buffer.push($1, $s || $o || $c || $t)\n      return $0 // Does nothing. Just satisfies Typescript's insatiable thirst for a string return;\n    } else if ($o) {\n      // Open\n      stack.push($o)\n    } else if ($c) {\n      // Close\n      stack.pop()\n    } else if ($t) {\n      // Toggle\n      if (stack[stack.length - 1] !== $t) stack.push($t)\n      else stack.pop()\n    } else {\n      // Split (if no stack) or EOF\n      if ($s ? !stack.length : !$1) {\n        buffer.push($1)\n        results.push(buffer.join(''))\n        buffer = []\n        return $0 // Does nothing. Just satisfies Typescript's insatiable thirst for a string return;\n      }\n    }\n    buffer.push($0)\n    return $0 // Does nothing. Just satisfies Typescript's insatiable thirst for a string return;\n  })\n  return results\n}\n\nexport const setIn = (target: { [key: string]: any }, keyPath: string[], value: any) => {\n  if (keyPath.length === 0) {\n    throw new Error('No keys provided in \"keyPath\" for \"setIn\"')\n  }\n  let i = 0\n  while (i < keyPath.length - 1) {\n    target = target[keyPath[i]]\n    i++\n  }\n  target[keyPath[i]] = value\n}\n\nexport const getIn = (target: { [key: string]: any }, keyPath: string[]): any => {\n  if (keyPath.length === 0) {\n    return target\n  }\n  if (keyPath.length === 1) {\n    return target[keyPath[0]]\n  }\n  return getIn(target[keyPath[0]], keyPath.slice(1))\n}\n\n// https://codereview.stackexchange.com/questions/45991/balanced-parentheses\nexport const parenthesesAreBalanced = (s: string) => {\n  const parentheses = '()'\n  const stack = []\n  let i = 0\n  let character = null\n  let bracePosition = 0\n\n  for (i = 0; i < s.length; i++) {\n    character = s[i]\n    bracePosition = parentheses.indexOf(character)\n\n    if (bracePosition === -1) {\n      continue\n    }\n\n    if (bracePosition % 2 === 0) {\n      stack.push(bracePosition + 1) // push next expected brace position\n    } else {\n      if (stack.length === 0 || stack.pop() !== bracePosition) {\n        return false\n      }\n    }\n  }\n\n  return stack.length === 0\n}\n","import {\n  EvaluationTree,\n  EvaluationTreeLeaf,\n  FilterEvaluator,\n  FilterGenerator,\n  Facets,\n  Item\n} from './types'\nimport Lapidary from './lapidary'\nimport { AND, OR, NOT } from './constants'\nimport { splitBalanced, parenthesesAreBalanced } from './utilities'\nimport { DefaultEvaluationGenerator } from './operations'\n\nconst FILTER_STRING_REGEX = /.+:.*:/gi\n// const FILTER_STRING_REGEX = /.+:.*:.+/gi\n\nconst alwaysTrueFilterEvaluator: FilterEvaluator = (item: Item, l: Lapidary) => true\n\nconst isInterpretable = (str: string) => {\n  /* Currently unused because of recursivelySplitString\n  if (str.startsWith('(') && str.endsWith(')')) {\n    return true\n  }\n  if (str === AND || str === OR) {\n    return true\n  }\n  */\n  if (str.match(FILTER_STRING_REGEX)) {\n    return true\n  }\n  return false\n}\n\nconst stripParens = (s: string) => {\n  if (s.startsWith('(') && s.endsWith(')')) {\n    return s.slice(1, -1)\n  }\n  return s\n}\n\n// Idk how to Type the return value for recursive functions\n// This should ultimately return String[][]\nconst recursivelySplitString = (input: string, depth: number): any => {\n  let strippedInput: string = stripParens(input)\n  // Must check for balanced parens. Blindly stripping based on the start and end characters is not safe.\n  // e.g: (name:=:james) OR (name:=:jane) would horribly fail\n  if (!parenthesesAreBalanced(strippedInput)) {\n    strippedInput = input\n  }\n  const split: string[] = splitBalanced(strippedInput)\n  if (split.length === 0 || split.length === 1) {\n    if (depth === 0) {\n      // If no recursion is needed\n      return [strippedInput]\n    }\n    return strippedInput\n  }\n  return split.map(s => recursivelySplitString(s, depth + 1))\n}\n\nconst stringToFilterEvaluator = (filterString: string, facets: Facets): FilterEvaluator => {\n  const [key, operation, parameters] = filterString.split(':')\n  const facetKey = key as keyof Facets\n\n  // Handle raw queries that don't match lapidary syntax\n  if (!isInterpretable(filterString)) {\n    return DefaultEvaluationGenerator(facetKey, parameters)\n  }\n\n  if (!facetKey || !facets[facetKey]) {\n    throw new Error(`Invalid facet key: \"${facetKey}\". Unable to interpret \"${filterString}\"`)\n  }\n\n  /*// If the regex is ever switched back to /.+:.*:.+/gi this will probably need to be re-enabled\n  if (!facets[facetKey]) {\n    throw new Error(`Invalid facet ${facetKey}. Unable to interpret \"${filterString}\"`)\n  }\n  */\n\n  const filterGenerator: FilterGenerator = facets[facetKey].operations[operation]\n\n  if (!filterGenerator) {\n    throw new Error(`Invalid operation \"${operation}\" for \"${facetKey}\"`)\n  }\n\n  return filterGenerator(facetKey, parameters)\n}\n\nexport const traverseEvaluationTree = (\n  item: Item,\n  evalutionTree: EvaluationTree | EvaluationTreeLeaf | null,\n  l: Lapidary\n): boolean => {\n  if (!evalutionTree) {\n    return false\n  }\n  // TODO: I have no idea how to do typechecking on union types. Maybe refactor the EvaluationTree and EvaluationTreeLeaf to be the same type.\n  if (evalutionTree.hasOwnProperty('filterEvaluator')) {\n    return (evalutionTree as EvaluationTreeLeaf).filterEvaluator(item, l)\n  }\n  const tree = evalutionTree as EvaluationTree\n\n  // TODO: This is kinda messy.... And I'm not even sure the last case is necessary\n  if (tree.left && tree.right) {\n    if (tree.joinType === AND) {\n      return (\n        traverseEvaluationTree(item, tree.left, l) &&\n        !tree.invert === traverseEvaluationTree(item, tree.right, l)\n      )\n    }\n    return (\n      traverseEvaluationTree(item, tree.left, l) ||\n      !tree.invert === traverseEvaluationTree(item, tree.right, l)\n    )\n  }\n  return traverseEvaluationTree(item, tree.left, l)\n}\n\nexport const recursivelyGenerateEvaluators = (\n  split: any,\n  facets: Facets\n): EvaluationTree | EvaluationTreeLeaf => {\n  if (Array.isArray(split)) {\n    if (split.length < 1) {\n      throw new Error('Invalid syntax')\n    }\n    // Special case for when the query string starts with NOT. e.g. \"NOT (is::duplicate)\"\n    if (split[0] === NOT && split[1]) {\n      return {\n        left: { filterEvaluator: alwaysTrueFilterEvaluator, raw: '' }, // Make a dummy left side that will always return true\n        joinType: AND,\n        invert: true,\n        right: recursivelyGenerateEvaluators(split[1], facets)\n      }\n    }\n    // Case like (foo:=:bar) which will become [\"foo:=:bar\"]\n    if (split.length === 1) {\n      return recursivelyGenerateEvaluators(split[0], facets)\n    }\n    // Explicit join type\n    if (split[1] === OR || split[1] === AND) {\n      const inverted = split[2] && split[2] === NOT\n      return {\n        left: recursivelyGenerateEvaluators(split[0], facets),\n        joinType: split[1],\n        invert: inverted, // \"foo:=:bar AND NOT bar:=:foo\"\n        right: recursivelyGenerateEvaluators(split.slice(inverted ? 3 : 2), facets)\n      }\n    }\n    // Implicit \"AND\" join type\n    const inverted = split[1] && split[1] === NOT\n    return {\n      left: recursivelyGenerateEvaluators(split[0], facets),\n      joinType: AND,\n      invert: inverted, // \"foo:=:bar NOT bar:=:foo\"\n      right: recursivelyGenerateEvaluators(split.slice(inverted ? 2 : 1), facets)\n    }\n  }\n  // String as EvaluationLeaf\n  return {\n    filterEvaluator: stringToFilterEvaluator(split, facets),\n    raw: split\n  }\n}\n\nconst generateEvaluationTree = (\n  input: string,\n  facets: Facets\n): EvaluationTree | EvaluationTreeLeaf => {\n  // Replace instances of multiple spaces with a single space\n  const squashedInput = input.replace(/\\s\\s+/g, ' ').trim()\n  const split: String[] = recursivelySplitString(squashedInput, 0)\n  const evaluationTree = recursivelyGenerateEvaluators(split, facets)\n  return evaluationTree\n}\n\nexport { generateEvaluationTree }\n","import { StringOperations, NumericOperations } from './operations'\nimport { EvaluationTree, EvaluationTreeLeaf, Item, Facets, Facet } from './types'\nimport { generateEvaluationTree, traverseEvaluationTree } from './helpers'\nimport { setIn, getIn } from './utilities'\nimport { FACET_SUGGESTION_REGEX } from './constants'\n\nexport default class Lapidary {\n  items: Item[]\n  facets: Facets\n  options: { [key: string]: any }\n  setInTransientContext: (keyPath: string[], value: any) => void\n  getInTransientContext: (keyPath: string[]) => any\n  setInPermanentContext: (keyPath: string[], value: any) => void\n  getInPermanentContext: (keyPath: string[]) => any\n  getEvaluationTree: (query: string) => EvaluationTree | EvaluationTreeLeaf\n  parseQuery: (query: string) => Item[]\n  parseEvaluationTree: (evalutionTree : EvaluationTree | EvaluationTreeLeaf) => Item[]\n  getSuggestions: (query: string, position: number) => string[]\n  defaultFacet: (i: Item, s: string | number) => boolean\n  defaultSuggestion: string\n  getCurrentIndex: () => number\n  getFacet: (key: keyof Facets) => Facet\n  // clearPermanentContext: () => void\n  private permanentContext: { [key: string]: any }\n  private transientContext: { [key: string]: any }\n  private clearTransientContext: () => void\n  private currentIndex: number\n  private setCurrentIndex: (i: number) => void\n\n  constructor(\n    items: Item[],\n    facets: Facets,\n    options: {\n      defaultFacet: (i: Item, s: string | number) => boolean\n      aliases: { [key: string]: keyof Facets }\n      defaultSuggestion: string\n    }\n  ) {\n    this.items = items\n    this.facets = facets\n    this.permanentContext = {}\n    this.transientContext = {}\n    this.defaultFacet = options.defaultFacet\n    this.defaultSuggestion = options.defaultSuggestion\n    this.currentIndex = 0\n    this.options = options\n    this.getFacet = (key: keyof Facets) => this.facets[key]\n    this.setCurrentIndex = (i: number) => (this.currentIndex = i)\n    this.getCurrentIndex = () => this.currentIndex\n    this.clearTransientContext = () => (this.transientContext = {})\n    // this.clearPermanentContext = () => (this.permanentContext = {})\n    this.setInTransientContext = (keyPath: string[], value: any) =>\n      setIn(this.transientContext, keyPath, value)\n    this.getInTransientContext = (keyPath: string[]) => getIn(this.transientContext, keyPath)\n    this.setInPermanentContext = (keyPath: string[], value: any) =>\n      setIn(this.permanentContext, keyPath, value)\n    this.getInPermanentContext = (keyPath: string[]) => getIn(this.permanentContext, keyPath)\n    this.getEvaluationTree = (query: string): EvaluationTree | EvaluationTreeLeaf => generateEvaluationTree(query, this.facets);\n    this.parseEvaluationTree = (evalutionTree : EvaluationTree | EvaluationTreeLeaf): Item[] => {\n      // Reset transient context before each run\n      this.clearTransientContext()\n      const result: Item[] = this.items.filter((item, index) => {\n        this.setCurrentIndex(index)\n        return traverseEvaluationTree(item, evalutionTree, this)\n      })\n      return result\n    }\n    this.parseQuery = (query: string): Item[] => { \n      if (query.trim() === '') {\n        return this.items\n      }\n      const evalutionTree: EvaluationTree | EvaluationTreeLeaf = generateEvaluationTree(\n        query,\n        this.facets\n      )\n      return this.parseEvaluationTree(evalutionTree)\n    }\n\n    /*\n      CASES:\n      1) [                ]\n      2) [hei             ]\n      3) [height:         ]\n      4) [height:>        ]\n      5) [height:>=       ]\n      6) [height:>=:      ]\n      7) [height:>=:6     ]\n      ----------\n      8) [height:>=:6_    ]\n      9) \n\n    */\n    this.getSuggestions = (query: string, position: number): string[] => {\n      const facetMatch = query.match(FACET_SUGGESTION_REGEX)\n      if (facetMatch) {\n        const matchingFacets = Object.keys(this.facets).filter(k => k.startsWith(facetMatch[0]))\n        return matchingFacets\n      }\n      return []\n    }\n  }\n}\n\nexport { StringOperations, NumericOperations, Lapidary }\n"],"names":[],"mappings":"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"}