{"version":3,"file":"lapidary.umd.js","sources":["../src/constants.ts","../src/operations.ts","../src/utilities.ts","../src/helpers.ts","../src/lapidary.ts"],"sourcesContent":["const BETWEEN = 'between'\nconst CASE_INSENSITIVE_EQUAL = '='\nconst CASE_INSENSITIVE_NOT_EQUAL = '!='\nconst CASE_SENSITIVE_EQUAL = '=='\nconst CASE_SENSITIVE_NOT_EQUAL = '!=='\nconst CONTAINS = 'contains'\nconst EQUAL = '='\nconst GREATER_THAN = '>'\nconst GREATER_THAN_OR_EQUAL = '>='\nconst IMPLICIT = ''\nconst INCLUSIVE_BETWEEN = 'inbetween'\nconst IS = 'is'\nconst LESS_THAN = '<'\nconst LESS_THAN_OR_EQUAL = '<='\nconst NOT_EQUAL = '!='\nconst NUMERIC = 'numeric'\nconst STRING = 'string'\n\nconst COMPARISONS = [\n  NOT_EQUAL,\n  LESS_THAN,\n  GREATER_THAN,\n  LESS_THAN_OR_EQUAL,\n  GREATER_THAN_OR_EQUAL,\n  EQUAL,\n  CONTAINS\n]\n\nconst AND = 'AND'\nconst OR = 'OR'\nconst NOT = 'NOT'\nconst XOR = 'XOR'\n\n/* SUGGESTION REGEX */\n\nconst FACET_SUGGESTION_REGEX = /\\w+/gi\n\n/* END SUGGESTION REGEX */\n\nexport {\n  AND,\n  BETWEEN,\n  CASE_INSENSITIVE_EQUAL,\n  CASE_INSENSITIVE_NOT_EQUAL,\n  CASE_SENSITIVE_EQUAL,\n  CASE_SENSITIVE_NOT_EQUAL,\n  COMPARISONS,\n  CONTAINS,\n  EQUAL,\n  FACET_SUGGESTION_REGEX,\n  GREATER_THAN,\n  GREATER_THAN_OR_EQUAL,\n  IMPLICIT,\n  INCLUSIVE_BETWEEN,\n  IS,\n  LESS_THAN,\n  LESS_THAN_OR_EQUAL,\n  NOT,\n  NOT_EQUAL,\n  NUMERIC,\n  OR,\n  STRING,\n  XOR\n}\n","import { FilterEvaluator, FilterGenerator, Item, Facets, OperationMapping } from './types'\n\nimport Lapidary from './lapidary'\nimport {\n  BETWEEN,\n  CASE_INSENSITIVE_EQUAL,\n  CASE_INSENSITIVE_NOT_EQUAL,\n  CASE_SENSITIVE_EQUAL,\n  CASE_SENSITIVE_NOT_EQUAL,\n  CONTAINS,\n  EQUAL,\n  GREATER_THAN,\n  GREATER_THAN_OR_EQUAL,\n  INCLUSIVE_BETWEEN,\n  LESS_THAN,\n  LESS_THAN_OR_EQUAL,\n  NOT_EQUAL\n} from './constants'\n\nconst checkValue = (v: any, facetKey: string | number) => {\n  if (typeof v === 'undefined' || v === '') {\n    throw new Error(`Expected a value for \"${facetKey}\"`)\n  }\n}\n\n// String quotes when doing string operations\nconst cleanString = (s: string, facetKey: string | number) => {\n  checkValue(s, facetKey)\n  return s.replace(/['\"]+/g, '')\n}\n// Interpret string value as number\nconst cleanNumber = (n: string, facetKey: string | number) => {\n  checkValue(n, facetKey)\n  const num = Number(n)\n  if (isNaN(num)) {\n    throw new Error(`Expected a numeric value for \"${facetKey}\". Received \"${n}\"`)\n  }\n  return num\n}\n\nconst StringEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] === cleanString(expression, facetKey)\n  }\n}\n\nconst StringCaseInsensetiveEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey].toLowerCase() === cleanString(expression, facetKey).toLowerCase()\n  }\n}\n\nconst StringContainsEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey].indexOf(cleanString(expression, facetKey)) >= 0\n  }\n}\n\nconst StringNegativeEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] !== cleanString(expression, facetKey)\n  }\n}\n\nconst StringNegativeCaseInsensitiveEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey].toLowerCase() !== cleanString(expression, facetKey).toLowerCase()\n  }\n}\n\nconst NumericEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] === cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericNegativeEqualityEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] !== cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericLTEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] < cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericLTEEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] <= cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericGTEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] > cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericGTEEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    return item[objectKey] >= cleanNumber(expression, facetKey)\n  }\n}\n\nconst NumericBetweenEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    const [lower, upper] = expression.split(',')\n    return (\n      item[objectKey] > cleanNumber(lower, facetKey) &&\n      item[objectKey] < cleanNumber(upper, facetKey)\n    )\n  }\n}\n\nconst NumericInclusiveBetweenEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => {\n    const objectKey = l.getFacet(facetKey).objectKey\n    const [lower, upper] = expression.split(',')\n    return (\n      item[objectKey] >= cleanNumber(lower, facetKey) &&\n      item[objectKey] <= cleanNumber(upper, facetKey)\n    )\n  }\n}\n\nconst DefaultEvaluationGenerator: FilterGenerator = (\n  facetKey: keyof Facets,\n  expression: string\n): FilterEvaluator => {\n  return (item: Item, l: Lapidary) => l.defaultFacet(item, facetKey)\n}\n\nconst StringOperations: OperationMapping = {\n  [CASE_SENSITIVE_EQUAL]: StringEqualityEvaluationGenerator,\n  [CASE_SENSITIVE_NOT_EQUAL]: StringNegativeEqualityEvaluationGenerator,\n  [CASE_INSENSITIVE_EQUAL]: StringCaseInsensetiveEqualityEvaluationGenerator,\n  [CASE_INSENSITIVE_NOT_EQUAL]: StringNegativeCaseInsensitiveEqualityEvaluationGenerator,\n  [CONTAINS]: StringContainsEvaluationGenerator\n}\n\nconst NumericOperations: OperationMapping = {\n  [EQUAL]: NumericEqualityEvaluationGenerator,\n  [NOT_EQUAL]: NumericNegativeEqualityEvaluationGenerator,\n  [GREATER_THAN]: NumericGTEvaluationGenerator,\n  [LESS_THAN]: NumericLTEvaluationGenerator,\n  [GREATER_THAN_OR_EQUAL]: NumericGTEEvaluationGenerator,\n  [LESS_THAN_OR_EQUAL]: NumericLTEEvaluationGenerator,\n  [BETWEEN]: NumericBetweenEvaluationGenerator,\n  [INCLUSIVE_BETWEEN]: NumericInclusiveBetweenEvaluationGenerator\n}\n\nexport { StringOperations, NumericOperations, DefaultEvaluationGenerator }\n","// https://gist.github.com/scottrippey/1349099\nexport const splitBalanced = (\n  input: string,\n  /* istanbul ignore next */\n  split: string = ' ',\n  open: string = '',\n  close: string = '',\n  toggle: string = '',\n  escape: string = ''\n): string[] => {\n  // Build the pattern from params with defaults:\n  const pattern = '([\\\\s\\\\S]*?)(e)?(?:(o)|(c)|(t)|(sp)|$)'\n    .replace('sp', split)\n    .replace('o', open || '[\\\\(\\\\{\\\\[]')\n    .replace('c', close || '[\\\\)\\\\}\\\\]]')\n    .replace('t', toggle || '[\\'\"]')\n    .replace('e', escape || '[\\\\\\\\]')\n  const r = new RegExp(pattern, 'gi')\n  const stack: string[] = []\n  let buffer: string[] = []\n  const results: string[] = []\n  // Clone the input string\n  const clonedInput = '' + input\n  clonedInput.replace(r, ($0, $1, $e, $o, $c, $t, $s, i) => {\n    if ($e) {\n      // Escape\n      buffer.push($1, $s || $o || $c || $t)\n      return $0 // Does nothing. Just satisfies Typescript's insatiable thirst for a string return;\n    } else if ($o) {\n      // Open\n      stack.push($o)\n    } else if ($c) {\n      // Close\n      stack.pop()\n    } else if ($t) {\n      // Toggle\n      if (stack[stack.length - 1] !== $t) stack.push($t)\n      else stack.pop()\n    } else {\n      // Split (if no stack) or EOF\n      if ($s ? !stack.length : !$1) {\n        buffer.push($1)\n        results.push(buffer.join(''))\n        buffer = []\n        return $0 // Does nothing. Just satisfies Typescript's insatiable thirst for a string return;\n      }\n    }\n    buffer.push($0)\n    return $0 // Does nothing. Just satisfies Typescript's insatiable thirst for a string return;\n  })\n  return results\n}\n\nexport const setIn = (target: { [key: string]: any }, keyPath: string[], value: any) => {\n  if (keyPath.length === 0) {\n    throw new Error('No keys provided in \"keyPath\" for \"setIn\"')\n  }\n  let i = 0\n  while (i < keyPath.length - 1) {\n    target = target[keyPath[i]]\n    i++\n  }\n  target[keyPath[i]] = value\n}\n\nexport const getIn = (target: { [key: string]: any }, keyPath: string[]): any => {\n  if (keyPath.length === 0) {\n    return target\n  }\n  if (keyPath.length === 1) {\n    return target[keyPath[0]]\n  }\n  return getIn(target[keyPath[0]], keyPath.slice(1))\n}\n\n// https://codereview.stackexchange.com/questions/45991/balanced-parentheses\nexport const parenthesesAreBalanced = (s: string) => {\n  const parentheses = '()'\n  const stack = []\n  let i = 0\n  let character = null\n  let bracePosition = 0\n\n  for (i = 0; i < s.length; i++) {\n    character = s[i]\n    bracePosition = parentheses.indexOf(character)\n\n    if (bracePosition === -1) {\n      continue\n    }\n\n    if (bracePosition % 2 === 0) {\n      stack.push(bracePosition + 1) // push next expected brace position\n    } else {\n      if (stack.length === 0 || stack.pop() !== bracePosition) {\n        return false\n      }\n    }\n  }\n\n  return stack.length === 0\n}\n","import {\n  EvaluationTree,\n  EvaluationTreeLeaf,\n  FilterEvaluator,\n  FilterGenerator,\n  Facets,\n  Item\n} from './types'\nimport Lapidary from './lapidary'\nimport { AND, OR, XOR, NOT } from './constants'\nimport { splitBalanced, parenthesesAreBalanced } from './utilities'\nimport { DefaultEvaluationGenerator } from './operations'\n\nconst FILTER_STRING_REGEX = /.+:.*:/gi\n// const FILTER_STRING_REGEX = /.+:.*:.+/gi\n\nconst alwaysTrueFilterEvaluator: FilterEvaluator = (item: Item, l: Lapidary) => true\n\nconst isInterpretable = (str: string) => {\n  /* Currently unused because of recursivelySplitString\n  if (str.startsWith('(') && str.endsWith(')')) {\n    return true\n  }\n  if (str === AND || str === OR) {\n    return true\n  }\n  */\n  if (str.match(FILTER_STRING_REGEX)) {\n    return true\n  }\n  return false\n}\n\nconst stripParens = (s: string) => {\n  if (s.startsWith('(') && s.endsWith(')')) {\n    return s.slice(1, -1)\n  }\n  return s\n}\n\n// Idk how to Type the return value for recursive functions\n// This should ultimately return String[][]\nconst recursivelySplitString = (input: string, depth: number): any => {\n  let strippedInput: string = stripParens(input)\n  // Must check for balanced parens. Blindly stripping based on the start and end characters is not safe.\n  // e.g: (name:=:james) OR (name:=:jane) would horribly fail\n  if (!parenthesesAreBalanced(strippedInput)) {\n    strippedInput = input\n  }\n  const split: string[] = splitBalanced(strippedInput)\n  if (split.length === 0 || split.length === 1) {\n    if (depth === 0) {\n      // If no recursion is needed\n      return [strippedInput]\n    }\n    return strippedInput\n  }\n  return split.map(s => recursivelySplitString(s, depth + 1))\n}\n\nconst stringToFilterEvaluator = (filterString: string, facets: Facets): FilterEvaluator => {\n  const [key, operation, parameters] = filterString.split(':')\n  const facetKey = key as keyof Facets\n\n  // Handle raw queries that don't match lapidary syntax\n  if (!isInterpretable(filterString)) {\n    return DefaultEvaluationGenerator(facetKey, parameters)\n  }\n\n  if (!facetKey || !facets[facetKey]) {\n    throw new Error(`Invalid facet key: \"${facetKey}\". Unable to interpret \"${filterString}\"`)\n  }\n\n  /*// If the regex is ever switched back to /.+:.*:.+/gi this will probably need to be re-enabled\n  if (!facets[facetKey]) {\n    throw new Error(`Invalid facet ${facetKey}. Unable to interpret \"${filterString}\"`)\n  }\n  */\n\n  const filterGenerator: FilterGenerator = facets[facetKey].operations[operation]\n\n  if (!filterGenerator) {\n    throw new Error(`Invalid operation \"${operation}\" for \"${facetKey}\"`)\n  }\n\n  return filterGenerator(facetKey, parameters)\n}\n\nexport const traverseEvaluationTree = (\n  item: Item,\n  evalutionTree: EvaluationTree | EvaluationTreeLeaf | null,\n  l: Lapidary\n): boolean => {\n  if (!evalutionTree) {\n    return false\n  }\n  // TODO: I have no idea how to do typechecking on union types. Maybe refactor the EvaluationTree and EvaluationTreeLeaf to be the same type.\n  if (evalutionTree.hasOwnProperty('filterEvaluator')) {\n    return (evalutionTree as EvaluationTreeLeaf).filterEvaluator(item, l)\n  }\n  const tree = evalutionTree as EvaluationTree\n\n  switch (tree.joinType) {\n    case AND:\n      return (\n        traverseEvaluationTree(item, tree.left, l) &&\n        !tree.invert === traverseEvaluationTree(item, tree.right, l)\n      )\n    case OR:\n      return (\n        traverseEvaluationTree(item, tree.left, l) ||\n        !tree.invert === traverseEvaluationTree(item, tree.right, l)\n      )\n    case XOR:\n      /* // from: http://www.howtocreate.co.uk/xor.html\n        if( !foo != !bar ) {\n          ...\n        }\n      */\n      return (\n        !traverseEvaluationTree(item, tree.left, l) !=\n        !(!tree.invert === traverseEvaluationTree(item, tree.right, l))\n      )\n    default:\n      throw new Error(`Unrecognized join type \"${tree.joinType}\"`)\n  }\n}\n\nexport const recursivelyGenerateEvaluators = (\n  split: any,\n  facets: Facets\n): EvaluationTree | EvaluationTreeLeaf => {\n  if (Array.isArray(split)) {\n    if (split.length < 1) {\n      throw new Error('Invalid syntax')\n    }\n    // Special case for when the query string starts with NOT. e.g. \"NOT (is::duplicate)\"\n    // TODO: Is the boolean check for && split[1] really necessary? I don't think so...\n    // TODO: This does not support leading \"OR NOT\" queries. Which I don't think are valid anyway given that\n    // the alwaysTrueFilterEvaluator will cause them to always be true.\n    // TODO: WTF does OR NOT do anyway??? test it!\n    // \"first:=:james OR NOT last:=:collins\" is the inverse of \"(NOT first:=:james) AND last:=:collins\"\n\n    if (split[0] === NOT && split[1]) {\n      return {\n        left: { filterEvaluator: alwaysTrueFilterEvaluator, raw: 'TRUE' }, // Make a dummy left side that will always return true\n        joinType: AND,\n        invert: true,\n        right: recursivelyGenerateEvaluators(split.slice(1), facets)\n      }\n    }\n    // Case like (foo:=:bar) which will become [\"foo:=:bar\"]\n    if (split.length === 1) {\n      return recursivelyGenerateEvaluators(split[0], facets)\n    }\n    // Explicit join type\n    if (split[1] === OR || split[1] === AND || split[1] === XOR) {\n      const inverted = split[2] && split[2] === NOT\n      return {\n        left: recursivelyGenerateEvaluators(split[0], facets),\n        joinType: split[1],\n        invert: inverted, // \"foo:=:bar AND NOT bar:=:foo\"\n        right: recursivelyGenerateEvaluators(split.slice(inverted ? 3 : 2), facets)\n      }\n    }\n    // Implicit \"AND\" join type\n    const inverted = split[1] && split[1] === NOT\n    return {\n      left: recursivelyGenerateEvaluators(split[0], facets),\n      joinType: AND,\n      invert: inverted, // \"foo:=:bar NOT bar:=:foo\"\n      right: recursivelyGenerateEvaluators(split.slice(inverted ? 2 : 1), facets)\n    }\n  }\n  // String as EvaluationLeaf\n  return {\n    filterEvaluator: stringToFilterEvaluator(split, facets),\n    raw: split\n  }\n}\n\nconst generateEvaluationTree = (\n  input: string,\n  facets: Facets\n): EvaluationTree | EvaluationTreeLeaf => {\n  // Replace instances of multiple spaces with a single space\n  const squashedInput = input.replace(/\\s\\s+/g, ' ').trim()\n  const split: String[] = recursivelySplitString(squashedInput, 0)\n  const evaluationTree = recursivelyGenerateEvaluators(split, facets)\n  return evaluationTree\n}\n\nexport { generateEvaluationTree }\n","import { StringOperations, NumericOperations } from './operations'\nimport { EvaluationTree, EvaluationTreeLeaf, Item, Facets, Facet } from './types'\nimport { generateEvaluationTree, traverseEvaluationTree } from './helpers'\nimport { setIn, getIn } from './utilities'\nimport { FACET_SUGGESTION_REGEX } from './constants'\n\nexport default class Lapidary {\n  items: Item[]\n  facets: Facets\n  options: { [key: string]: any }\n  setInTransientContext: (keyPath: string[], value: any) => void\n  getInTransientContext: (keyPath: string[]) => any\n  setInPermanentContext: (keyPath: string[], value: any) => void\n  getInPermanentContext: (keyPath: string[]) => any\n  getEvaluationTree: (query: string) => EvaluationTree | EvaluationTreeLeaf\n  parseQuery: (query: string) => Item[]\n  parseEvaluationTree: (evalutionTree: EvaluationTree | EvaluationTreeLeaf) => Item[]\n  getSuggestions: (query: string, position: number) => string[]\n  defaultFacet: (i: Item, s: string | number) => boolean\n  defaultSuggestion: string\n  getCurrentIndex: () => number\n  getFacet: (key: keyof Facets) => Facet\n  // clearPermanentContext: () => void\n  private permanentContext: { [key: string]: any }\n  private transientContext: { [key: string]: any }\n  private clearTransientContext: () => void\n  private currentIndex: number\n  private setCurrentIndex: (i: number) => void\n\n  constructor(\n    items: Item[],\n    facets: Facets,\n    options: {\n      defaultFacet: (i: Item, s: string | number) => boolean\n      aliases: { [key: string]: keyof Facets }\n      defaultSuggestion: string\n    }\n  ) {\n    this.items = items\n    this.facets = facets\n    this.permanentContext = {}\n    this.transientContext = {}\n    this.defaultFacet = options.defaultFacet\n    this.defaultSuggestion = options.defaultSuggestion\n    this.currentIndex = 0\n    this.options = options\n    this.getFacet = (key: keyof Facets) => this.facets[key]\n    this.setCurrentIndex = (i: number) => (this.currentIndex = i)\n    this.getCurrentIndex = () => this.currentIndex\n    this.clearTransientContext = () => (this.transientContext = {})\n    // this.clearPermanentContext = () => (this.permanentContext = {})\n    this.setInTransientContext = (keyPath: string[], value: any) =>\n      setIn(this.transientContext, keyPath, value)\n    this.getInTransientContext = (keyPath: string[]) => getIn(this.transientContext, keyPath)\n    this.setInPermanentContext = (keyPath: string[], value: any) =>\n      setIn(this.permanentContext, keyPath, value)\n    this.getInPermanentContext = (keyPath: string[]) => getIn(this.permanentContext, keyPath)\n    this.getEvaluationTree = (query: string): EvaluationTree | EvaluationTreeLeaf =>\n      generateEvaluationTree(query, this.facets)\n    this.parseEvaluationTree = (evalutionTree: EvaluationTree | EvaluationTreeLeaf): Item[] => {\n      // Reset transient context before each run\n      this.clearTransientContext()\n      const result: Item[] = this.items.filter((item, index) => {\n        this.setCurrentIndex(index)\n        return traverseEvaluationTree(item, evalutionTree, this)\n      })\n      return result\n    }\n    this.parseQuery = (query: string): Item[] => {\n      if (query.trim() === '') {\n        return this.items\n      }\n      const evalutionTree: EvaluationTree | EvaluationTreeLeaf = generateEvaluationTree(\n        query,\n        this.facets\n      )\n      return this.parseEvaluationTree(evalutionTree)\n    }\n\n    /*\n      CASES:\n      1) [                ]\n      2) [hei             ]\n      3) [height:         ]\n      4) [height:>        ]\n      5) [height:>=       ]\n      6) [height:>=:      ]\n      7) [height:>=:6     ]\n      ----------\n      8) [height:>=:6_    ]\n      9) \n\n    */\n    this.getSuggestions = (query: string, position: number): string[] => {\n      const facetMatch = query.match(FACET_SUGGESTION_REGEX)\n      if (facetMatch) {\n        const matchingFacets = Object.keys(this.facets).filter(k => k.startsWith(facetMatch[0]))\n        return matchingFacets\n      }\n      return []\n    }\n  }\n}\n\nexport { StringOperations, NumericOperations, Lapidary }\n"],"names":[],"mappings":"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"}